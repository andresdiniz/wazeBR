<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.6.0/leaflet.polylineDecorator.min.js"></script>

{# 
    1. CARREGAMENTO DA API DO GOOGLE MAPS 
    Incluímos o script do Google Maps, mas ele só será usado se o provedor 'gmaps' for selecionado.
    O parâmetro 'libraries=geometry' é útil para cálculos, e 'v=beta' é comum para recursos de rotas.
#}
<script async defer src="https://maps.googleapis.com/maps/api/js?key=SUA_CHAVE_DE_API_DO_GOOGLE_AQUI&libraries=geometry"></script>

<div class="container mt-4 mb-4">
    <div class="row">
        <div class="col-lg-6 mb-3">
            <h3 class="text-primary">Criar Alerta</h3>
        </div>
    </div>
    <div class="row">
        <div class="col-lg-8">
            <div class="card shadow-sm p-4">
                <form action="api.php?action=cadastrar_evento" method="post" id="eventoForm">

                    <div>
                        <input type="hidden" name="id_parceiro" value="{{ id_parceiro }}">
                        {# Inputs para armazenar a polilinha/coordenada e o nome da rua final #}
                        <input type="hidden" id="finalPolylineInput" name="coordenadas" required>
                        <input type="hidden" id="finalStreetNameInput" name="rua" required>
                    </div>

                    {# 2. NOVO HTML PARA SELETOR DE PROVEDOR #}
                    <div class="mb-3">
                        <label class="form-label">Provedor de Mapeamento (para Segmento)</label>
                        <div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="radio" name="map_provider" id="providerOSM" value="osm" checked>
                                <label class="form-check-label" for="providerOSM">OpenStreetMap (OSM)</label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="radio" name="map_provider" id="providerGMaps" value="gmaps">
                                <label class="form-check-label" for="providerGMaps">Google Maps</label>
                            </div>
                        </div>
                    </div>

                    <div class="mb-3">
                        <label for="nome" class="form-label">Descrição do Evento</label>
                        <input type="text" class="form-control" id="nome" name="nome" required
                           placeholder="Ex: Obra na via X">
                    </div>

                    {# ... Mantenha o restante dos seus campos de formulário aqui ... #}

                    <button type="submit" class="btn btn-primary">Salvar Alerta</button>
                </form>
            </div>
        </div>
    </div>
    {# ... Mantenha a seção de mapa e outros conteúdos aqui ... #}
</div>

<style>
/* ... Mantenha seus estilos CSS aqui ... */
    @media (max-width: 576px) {
        .card .row .col-md-4 {
            flex: 0 0 100%;
            max-width: 100%;
        }
    }
</style>

<script>
//FUNCIONANDO PERFEITAMENTE! GRAÇAS A DEUS!
// Função para carregar subtipos usando a variável injetada pelo Twig (SEM AJAX)
function loadSubtypes(tipoId) {
    const subtipoSelect = document.getElementById('subtipo');
    // Reseta o estado do campo
    subtipoSelect.innerHTML = '<option value="">Selecione um Subtipo</option>';
    subtipoSelect.disabled = true;
    if (!tipoId) {
        return;
    }
    
    // Obtém os subtipos do objeto global (ASSUMIDO QUE SUBTIPOS_POR_TIPO ESTÁ DEFINIDO NO TWIG)
    const subtypes = typeof SUBTIPOS_POR_TIPO !== 'undefined' ? SUBTIPOS_POR_TIPO[tipoId] || [] : []; 

    if (subtypes.length > 0) {
        subtypes.forEach(subtipo => {
            const option = document.createElement('option');
            // Usamos o 'id' como o valor da opção
            option.value = subtipo.id; 
            option.textContent = subtipo.name;
            subtipoSelect.appendChild(option);
        });
        subtipoSelect.disabled = false; // Habilita o campo após o carregamento
    } else {
        subtipoSelect.innerHTML = '<option value="">Nenhum Subtipo Encontrado</option>';
    }
}
// ... (Seu evento de escuta para 'tipo' deve estar aqui, se não estiver usando Twig para o evento)
// Ex: document.getElementById('tipo').addEventListener('change', (e) => loadSubtypes(e.target.value));

// -------------------------------------------------------------
// 3. CÓDIGO REFATORADO PARA IDENTIFICAÇÃO DE SEGMENTO (OSM / GMAPS)
// -------------------------------------------------------------

// CONFIGURAÇÃO - SUBSTITUA COM SEUS VALORES REAIS
const GMAPS_API_KEY = 'SUA_CHAVE_DE_API_DO_GOOGLE_AQUI'; 
// URL para um serviço que faça "snap-to-road" com dados OSM (ex: OSRM, GraphHopper ou um serviço de backend próprio)
const OSM_SNAPPING_URL = 'https://router.project-osrm.org/nearest/v1/driving/'; // Exemplo OSRM: /lat,lng

/**
 * Funções de serviço para cada provedor.
 */
const RoadSegmentService = {
    // Implementação para OpenStreetMap (usando um endpoint externo simulado)
    osm: async (lat, lng) => {
        console.log(`Buscando segmento OSM para: ${lat}, ${lng}`);
        
        // Exemplo usando OSRM Nearest API. Nota: O OSRM retorna o ponto ajustado e metadados básicos.
        const url = `${OSM_SNAPPING_URL}${lng},${lat}`; 
        
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Falha ao obter dados OSM. Verifique o serviço de Snap-to-Road (OSRM/backend).');
            }
            const data = await response.json();
            
            if (data.waypoints && data.waypoints.length > 0) {
                const waypoint = data.waypoints[0];
                const snappedCoords = waypoint.location; // [lng, lat]
                
                // O OSRM não fornece o nome da rua diretamente. Você precisará de um serviço de geocodificação reversa.
                // Aqui, usamos um valor padrão. Adapte esta parte para usar o Nominatim ou um serviço próprio.
                const streetName = waypoint.name || 'Rua Desconhecida (OSM)';
                
                // Formato final: "lat,lng"
                return { rua: streetName, coordenadas: `${snappedCoords[1]},${snappedCoords[0]}` };

            } else {
                 return { rua: 'Não Encontrado (OSM)', coordenadas: '' };
            }

        } catch (error) {
            console.error("Erro no serviço OSM:", error);
            return { rua: 'Erro OSM', coordenadas: '' };
        }
    },

    // Implementação para Google Maps Roads API (Nearest Roads)
    gmaps: async (lat, lng) => {
        console.log(`Buscando segmento GMaps para: ${lat}, ${lng}`);
        
        // 1. Google Roads API: Encontra o segmento de via mais próximo
        const gmapsRoadsUrl = 'https://roads.googleapis.com/v1/nearestRoads';
        const roadsUrl = `${gmapsRoadsUrl}?points=${lat},${lng}&key=${GMAPS_API_KEY}`;
        
        try {
            const roadsResponse = await fetch(roadsUrl);
            const roadsData = await roadsResponse.json();
            
            if (!roadsData.snappedPoints || roadsData.snappedPoints.length === 0) {
                console.warn('Google Roads API não encontrou segmento para o ponto.');
                return { rua: 'Não Encontrado (GMaps)', coordenadas: '' };
            }

            const snappedPoint = roadsData.snappedPoints[0];
            const snappedCoords = snappedPoint.location; // {latitude, longitude}
            
            // 2. Google Geocoding API: Usa a coordenada ajustada para obter o nome da rua
            const geocodingUrl = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${snappedCoords.latitude},${snappedCoords.longitude}&key=${GMAPS_API_KEY}`;
            
            const geoResponse = await fetch(geocodingUrl);
            const geoData = await geoResponse.json();
            
            let streetName = 'Rua Desconhecida (GMaps)';

            if (geoData.results && geoData.results.length > 0) {
                // Tenta encontrar o nome da rua ('route')
                const roadComponent = geoData.results[0].address_components.find(comp => comp.types.includes('route'));
                streetName = roadComponent ? roadComponent.long_name : geoData.results[0].formatted_address; // Se não encontrar, usa o endereço completo
            }
            
            // Formato final: "lat,lng"
            return { rua: streetName, coordenadas: `${snappedCoords.latitude},${snappedCoords.longitude}` };

        } catch (error) {
            console.error("Erro no serviço GMaps:", error);
            return { rua: 'Erro GMaps', coordenadas: '' };
        }
    }
};


/**
 * 4. FUNÇÃO PRINCIPAL ABSTRATA
 * @param {number} lat - Latitude do ponto.
 * @param {number} lng - Longitude do ponto.
 * @param {string} provider - 'osm' ou 'gmaps'.
 * @returns {Promise<{rua: string, coordenadas: string}>} - Objeto com nome da rua e polilinha/coordenadas.
 */
async function identifyRoadSegment(lat, lng, provider) {
    if (!RoadSegmentService[provider]) {
        console.error(`Provedor '${provider}' não suportado.`);
        return { rua: 'Provedor Inválido', coordenadas: '' };
    }
    return await RoadSegmentService[provider](lat, lng);
}

// -------------------------------------------------------------
// 5. FUNÇÃO PARA TRATAR O EVENTO DE CLIQUE NO MAPA
// -------------------------------------------------------------

// Adapte esta função para o evento de clique do seu mapa (ex: Leaflet, Google Maps JS API, etc.)
function handleMapPointSelection(mapEvent) {
    // Exemplo de como obter as coordenadas de um evento do mapa (pode variar dependendo da biblioteca)
    // Se estiver usando Leaflet: mapEvent.latlng.lat / mapEvent.latlng.lng
    // Se estiver usando Google Maps JS API: mapEvent.latLng.lat() / mapEvent.latLng.lng()
    
    // Supondo que você tem um objeto 'latlng' ou similar:
    const lat = mapEvent.latlng ? mapEvent.latlng.lat : mapEvent.latLng.lat();
    const lng = mapEvent.latlng ? mapEvent.latlng.lng : mapEvent.latLng.lng();
    
    // Pega o provedor selecionado no rádio button
    const selectedProvider = document.querySelector('input[name="map_provider"]:checked').value;
    
    if (!lat || !lng) {
        alert("Coordenadas do ponto não disponíveis.");
        return;
    }
    
    // Chama a função refatorada
    identifyRoadSegment(lat, lng, selectedProvider)
        .then(data => {
            // Atualiza os campos escondidos no seu formulário
            const finalPolylineInput = document.getElementById('finalPolylineInput');
            const finalStreetNameInput = document.getElementById('finalStreetNameInput');
            
            if (data.coordenadas && data.rua && data.rua.indexOf('Erro') === -1 && data.rua.indexOf('Não Encontrado') === -1) {
                finalPolylineInput.value = data.coordenadas;
                finalStreetNameInput.value = data.rua;
                alert(`Segmento identificado com sucesso: ${data.rua} (Via ${selectedProvider}). Coordenadas salvas: ${data.coordenadas}`);
            } else {
                finalPolylineInput.value = '';
                finalStreetNameInput.value = '';
                alert(`Não foi possível identificar o segmento usando ${selectedProvider}. Resultado: ${data.rua}`);
            }
        })
        .catch(error => {
            console.error("Erro geral no processamento do segmento:", error);
            alert("Ocorreu um erro ao processar a identificação do segmento.");
        });
}

// ADICIONE AQUI O CÓDIGO DE INICIALIZAÇÃO DO SEU MAPA
// E VINCULE O EVENTO DE CLIQUE À FUNÇÃO handleMapPointSelection.
/*
// Exemplo Leaflet:
const map = L.map('id_do_seu_mapa').setView([LATITUDE, LONGITUDE], 13);
map.on('click', handleMapPointSelection); 
*/

</script>