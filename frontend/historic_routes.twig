<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.13.7/css/dataTables.bootstrap5.min.css">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.0.1/dist/chartjs-plugin-zoom.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>
<script src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.13.7/js/dataTables.bootstrap5.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.0.1/dist/chartjs-plugin-annotation.min.js"></script>

<style>
    /* Esconder gráficos em mobile */
    @media (max-width: 767px) {
        #chartVelocidade, 
        #chartTempo {
            display: none !important;
        }
        
        /* Opcional: Ajustar margens */
        .mt-4.d-flex {
            margin-top: 1rem !important;
        }
    }
</style>

<div class="container mt-4">
    <h2 class="text-center mb-4">Selecionar Rota e Período</h2>
    <form method="GET" class="row g-3">
        <div class="col-md-4">
            <label for="route_id" class="form-label">Rota:</label>
            <select name="route_id" id="route_id" class="form-select" required>
                <option value="">Selecione uma rota</option>
                {% for route in routes %}
                    <option value="{{ route.id }}" {% if route.id == selected_route %}selected{% endif %}>
                        {{ route.name }}
                    </option>
                {% endfor %}
            </select>
        </div>

        <div class="col-md-3">
            <label for="start_date" class="form-label">Início:</label>
            <input type="date" name="start_date" id="start_date" value="{{ start_date }}" class="form-control" required>
        </div>

        <div class="col-md-3">
            <label for="end_date" class="form-label">Fim:</label>
            <input type="date" name="end_date" id="end_date" value="{{ end_date }}" class="form-control" required>
        </div>

        <div class="col-md-2 d-flex align-items-end">
            <button type="submit" class="btn btn-primary w-100">Buscar</button>
        </div>
    </form>

    {% if dados.historic_routes %}
        <div class="mt-4" id="sentimentMessage">
            <!-- Análise por período será exibida aqui -->
        </div>
        <div class="mt-4">
            <h3 class="text-center">Análise de Desempenho com Gráficos</h3>
            <canvas id="chartVelocidade"></canvas>
            <canvas id="chartTempo" class="mt-4"></canvas>
        </div>

        <div class="mt-4 d-flex justify-content-center gap-3">
            <button class="btn btn-success" onclick="exportTableToCSV()">Exportar CSV</button>
            <button class="btn btn-warning" onclick="exportTableToExcel()">Exportar Excel</button>
            <button class="btn btn-info" onclick="downloadChart('chartVelocidade')">Baixar Gráfico de Velocidade</button>
            <button class="btn btn-info" onclick="downloadChart('chartTempo')">Baixar Gráfico de Tempo</button>
        </div>

        <h3 class="mt-4 text-center">Tabela de Dados</h3>
        <table class="table table-bordered table-striped text-center mt-3" id="dataTable" style="width:100%">
            <thead class="table-dark">
                <tr>
                    <th>Data/Hora</th>
                    <th>Velocidade (km/h)</th>
                    <th>Tempo (s)</th>
                </tr>
            </thead>
            <tbody>
                {% for item in dados.historic_routes %}
                    <tr>
                        <td>{{ item.data }}</td>
                        <td>{{ item.velocidade }}</td>
                        <td>{{ item.tempo }}</td>
                    </tr>
                {% else %}
                    <tr>
                        <td colspan="3">Nenhum dado encontrado.</td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>

    {% endif %}
</div>

<script>
    // Definir alias jq para jQuery com noConflict
    var jq = jQuery.noConflict(true);

    document.addEventListener("DOMContentLoaded", function() {
        {% if dados.historic_routes %}
            // Inicialização do DataTables com jq (não alterado)
            jq('#dataTable').DataTable({
                language: {
                    url: '//cdn.datatables.net/plug-ins/1.13.7/i18n/pt-BR.json'
                },
                dom: 'Bfrtip',
                buttons: [],
                pageLength: 10,
                lengthMenu: [5, 10, 25, 50],
                order: [[0, 'desc']]
            });

            const routeName = document.getElementById('route_id').selectedOptions[0].text;
            const labels = [
                {% for item in dados.historic_routes %}
                    "{{ item.data }}",
                {% endfor %}
            ];

            const velocidades = [
                {% for item in dados.historic_routes %}
                    {{ item.velocidade }},
                {% endfor %}
            ];

            const tempos = [
                {% for item in dados.historic_routes %}
                    {{ item.tempo }},
                {% endfor %}
            ];

            // NOVO: Funções auxiliares para marcações
            function getMinMaxIndices(arr) {
                const max = Math.max(...arr);
                const min = Math.min(...arr);
                return {
                    maxIndex: arr.indexOf(max),
                    minIndex: arr.indexOf(min)
                };
            }

            function getCurrentStatus(speed, avg) {
                if (speed >= avg * 1.20) return ['success', 'Excelente'];
                if (speed >= avg * 1.10) return ['info', 'Bom'];
                if (speed >= avg * 0.95) return ['primary', 'Normal'];
                if (speed >= avg * 0.85) return ['warning', 'Atenção'];
                return ['danger', 'Crítico'];
            }

            // Configuração comum para os gráficos (modificado)
            const chartOptions = {
                responsive: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(tooltipItem) {
                                return `${tooltipItem.dataset.label}: ${tooltipItem.raw} ${tooltipItem.dataset.label.includes('Velocidade') ? 'km/h' : 's'}`;
                            }
                        }
                    },
                    zoom: {
                        wheel: { enabled: true, speed: 0.1 },
                        pinch: { enabled: true },
                        drag: { enabled: true, mode: 'xy' }
                    },
                    // NOVO: Plugin de anotações
                    annotation: {
                        annotations: {}
                    }
                },
                scales: { y: { beginAtZero: true, ticks: { stepSize: 10 } } }
            };

            // Gráfico de Velocidade (modificado)
            const velAnnotations = getMinMaxIndices(velocidades);
            new Chart(document.getElementById("chartVelocidade"), {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Velocidade na Rota: ${routeName}`,
                        data: velocidades,
                        borderColor: "blue",
                        fill: false,
                        tension: 0.3,
                        borderWidth: 2,
                        // NOVO: Pontos destacados
                        pointBackgroundColor: velocidades.map((v, i) => 
                            i === velAnnotations.maxIndex ? 'rgba(255,0,0,0.8)' :
                            i === velAnnotations.minIndex ? 'rgba(0,0,255,0.8)' : 'rgba(0,0,0,0.2)'
                        ),
                        pointRadius: velocidades.map((v, i) => 
                            (i === velAnnotations.maxIndex || i === velAnnotations.minIndex) ? 6 : 3
                        )
                    }]
                },
                options: {
                    ...chartOptions,
                    plugins: {
                        ...chartOptions.plugins,
                        title: {
                            display: true,
                            text: `Velocidade na Rota: ${routeName}`,
                            font: { size: 18 }
                        },
                        // NOVO: Anotações
                        annotation: {
                            annotations: {
                                maxLine: {
                                    type: 'line',
                                    yMin: velocidades[velAnnotations.maxIndex],
                                    yMax: velocidades[velAnnotations.maxIndex],
                                    borderColor: 'red',
                                    borderWidth: 2,
                                    label: {
                                        content: `Máximo: ${velocidades[velAnnotations.maxIndex].toFixed(1)} km/h`,
                                        position: 'end'
                                    }
                                },
                                minLine: {
                                    type: 'line',
                                    yMin: velocidades[velAnnotations.minIndex],
                                    yMax: velocidades[velAnnotations.minIndex],
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    label: {
                                        content: `Mínimo: ${velocidades[velAnnotations.minIndex].toFixed(1)} km/h`,
                                        position: 'end'
                                    }
                                }
                            }
                        }
                    }
                }
            });

            // Gráfico de Tempo (modificado)
            const tempoAnnotations = getMinMaxIndices(tempos);
            new Chart(document.getElementById("chartTempo"), {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Tempo na Rota: ${routeName}`,
                        data: tempos,
                        borderColor: "red",
                        fill: false,
                        tension: 0.3,
                        borderWidth: 2,
                        // NOVO: Pontos destacados
                        pointBackgroundColor: tempos.map((t, i) => 
                            i === tempoAnnotations.maxIndex ? 'rgba(255,0,0,0.8)' :
                            i === tempoAnnotations.minIndex ? 'rgba(0,0,255,0.8)' : 'rgba(0,0,0,0.2)'
                        ),
                        pointRadius: tempos.map((t, i) => 
                            (i === tempoAnnotations.maxIndex || i === tempoAnnotations.minIndex) ? 6 : 3
                        )
                    }]
                },
                options: {
                    ...chartOptions,
                    plugins: {
                        ...chartOptions.plugins,
                        title: {
                            display: true,
                            text: `Tempo de Percurso na Rota: ${routeName}`,
                            font: { size: 18 }
                        },
                        // NOVO: Anotações
                        annotation: {
                            annotations: {
                                maxLine: {
                                    type: 'line',
                                    yMin: tempos[tempoAnnotations.maxIndex],
                                    yMax: tempos[tempoAnnotations.maxIndex],
                                    borderColor: 'red',
                                    borderWidth: 2,
                                    label: {
                                        content: `Máximo: ${tempos[tempoAnnotations.maxIndex].toFixed(1)} s`,
                                        position: 'end'
                                    }
                                },
                                minLine: {
                                    type: 'line',
                                    yMin: tempos[tempoAnnotations.minIndex],
                                    yMax: tempos[tempoAnnotations.minIndex],
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    label: {
                                        content: `Mínimo: ${tempos[tempoAnnotations.minIndex].toFixed(1)} s`,
                                        position: 'end'
                                    }
                                }
                            }
                        }
                    }
                }
            });

            // Cálculo da média geral (não alterado)
            const overallAvg = velocidades.reduce((a, b) => a + b, 0) / velocidades.length;
            
            // NOVO: Status do momento atual
            const currentSpeed = velocidades[velocidades.length - 1];
            const currentTime = labels[labels.length - 1];
            const [currentStatus, currentStatusText] = getCurrentStatus(currentSpeed, overallAvg);
            
            const statusHTML = `
            <div class="row mb-4">
                <div class="col-md-12">
                    <div class="card border-${currentStatus} shadow">
                        <div class="card-body">
                            <div class="row align-items-center">
                                <div class="col-md-4 text-center">
                                    <div class="display-4 text-${currentStatus}">${currentStatusText}</div>
                                    <small class="text-muted">${currentTime}</small>
                                </div>
                                <div class="col-md-8">
                                    <dl class="row mb-0">
                                        <dt class="col-sm-4">Velocidade Atual</dt>
                                        <dd class="col-sm-8">${currentSpeed.toFixed(1)} km/h</dd>
                                        
                                        <dt class="col-sm-4">Média Periódica</dt>
                                        <dd class="col-sm-8">${overallAvg.toFixed(1)} km/h</dd>
                                        
                                        <dt class="col-sm-4">Desvio</dt>
                                        <dd class="col-sm-8">
                                            <span class="badge bg-${currentStatus}">
                                                ${((currentSpeed - overallAvg)/overallAvg * 100).toFixed(1)}%
                                            </span>
                                        </dd>
                                    </dl>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>`;
            
            // Análise por período (não alterado)
            const timeAnalysis = {
                madrugada1: { start: 0, end: 3, speeds: [], label: 'Madrugada (00:00 - 03:00)' },
                madrugada2: { start: 3, end: 6, speeds: [], label: 'Madrugada (03:00 - 06:00)' },
                manha1: { start: 6, end: 9, speeds: [], label: 'Manhã (06:00 - 09:00)' },
                manha2: { start: 9, end: 12, speeds: [], label: 'Manhã (09:00 - 12:00)' },
                tarde1: { start: 12, end: 15, speeds: [], label: 'Tarde (12:00 - 15:00)' },
                tarde2: { start: 15, end: 18, speeds: [], label: 'Tarde (15:00 - 18:00)' },
                noite1: { start: 18, end: 21, speeds: [], label: 'Noite (18:00 - 21:00)' },
                noite2: { start: 21, end: 24, speeds: [], label: 'Noite (21:00 - 00:00)' }
            };

            // Coleta de dados por período (não alterado)
            labels.forEach((label, index) => {
                const [date, time] = label.split(' ');
                const hour = parseInt(time.split(':')[0], 10);
                
                for (const period of Object.values(timeAnalysis)) {
                    if (hour >= period.start && hour < period.end) {
                        period.speeds.push(velocidades[index]);
                        break;
                    }
                }
            });

            // Geração da análise dinâmica (não alterado)
            let analysisHTML = `
                <h4 class="mt-4 text-center">Análise de Desempenho por Período</h4>
                <div class="alert alert-info">
                    Média geral do período selecionado: <strong>${overallAvg.toFixed(1)} km/h</strong><br>
                    Classificação baseada no desempenho relativo ao período
                </div>
                <div class="row mt-3">`;

            Object.values(timeAnalysis).forEach(period => {
                if (period.speeds.length === 0) return;
                
                const avg = period.speeds.reduce((a, b) => a + b, 0) / period.speeds.length;
                const deviation = ((avg - overallAvg) / overallAvg * 100).toFixed(1);
                
                let status = 'secondary';
                let statusText = 'Sem dados suficientes';
                let statusDescription = '';

                // Classificação dinâmica (alterado para 5 níveis)
                if (avg >= overallAvg * 1.20) {
                    status = 'success';
                    statusText = 'Excelente';
                    statusDescription = 'Muito acima da média';
                } else if (avg >= overallAvg * 1.10) {
                    status = 'info';
                    statusText = 'Bom';
                    statusDescription = 'Acima da média';
                } else if (avg >= overallAvg * 0.95) {
                    status = 'primary';
                    statusText = 'Normal';
                    statusDescription = 'Dentro da média';
                } else if (avg >= overallAvg * 0.85) {
                    status = 'warning';
                    statusText = 'Atenção';
                    statusDescription = 'Abaixo da média';
                } else {
                    status = 'danger';
                    statusText = 'Crítico';
                    statusDescription = 'Muito abaixo da média';
                }

                analysisHTML += `
                    <div class="col-md-3 mb-3">
                        <div class="card border-${status} h-100">
                            <div class="card-body text-center">
                                <h5 class="card-title">${period.label}</h5>
                                <div class="display-4 text-${status}">${statusText}</div>
                                <p class="card-text mt-2">
                                    Média: <strong>${avg.toFixed(1)} km/h</strong><br>
                                    Desvio: ${deviation}%<br>
                                    Registros: ${period.speeds.length}<br>
                                    <small>${statusDescription}</small>
                                </p>
                            </div>
                        </div>
                    </div>`;
            });

            analysisHTML += '</div>';
            
            // Inserir elementos na página (modificado)
            document.getElementById("sentimentMessage").innerHTML = statusHTML + analysisHTML;
        {% endif %}
    });

    // Função de exportação para CSV com ordenação crescente por Data/Hora
    function exportTableToCSV() {
        const dt = jq('#dataTable').DataTable();
        let data = dt.rows().data().toArray();

        // Ordenar os dados pela primeira coluna (Data/Hora)
        data.sort((a, b) => new Date(a[0]) - new Date(b[0]));

        let csvContent = "Data/Hora,Velocidade (km/h),Tempo (s)\n";

        data.forEach(row => {
            const linhaFormatada = row.map((cell, index) => {
                if (index === 1 || index === 2) {
                    return parseFloat(cell).toFixed(2); // Formatar números com 2 casas decimais
                }
                return `"${cell}"`; // Aspas para proteger campos textuais
            }).join(",");

            csvContent += linhaFormatada + "\n";

            // Adicionar previsões
            if(previsaoVelocidade) {
                csvContent += "\nPrevisões Futuras\n";
                previsaoVelocidade.previsoes.forEach((v, i) => {
                    csvContent += `Próxima ${i + 1} hora,${v.toFixed(1)},N/A\n`;
                });
            }
        });

        const blob = new Blob(["\uFEFF" + csvContent], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `dados_completos_${new Date().toISOString().slice(0, 10)}.csv`;
        link.click();
    }

    // Função de exportação para Excel com ordenação crescente por Data/Hora
    function exportTableToExcel() {
        const dt = jq('#dataTable').DataTable();
        let data = dt.rows().data().toArray();

        // Ordenar os dados pela primeira coluna (Data/Hora)
        data.sort((a, b) => new Date(a[0]) - new Date(b[0]));

        // Criar array com cabeçalhos
        const header = ["Data/Hora", "Velocidade (km/h)", "Tempo (s)"];
        const wsData = [header];

        // Adicionar dados formatados
        data.forEach(row => {
            wsData.push([
                row[0], // Data/Hora
                parseFloat(row[1]).toFixed(2), // Velocidade
                parseFloat(row[2]).toFixed(2)  // Tempo
            ]);
        });

        const ws = XLSX.utils.aoa_to_sheet(wsData);

        // Formatar colunas numéricas
        ws['!cols'] = [
            { wch: 20 }, // Data/Hora
            { wch: 15 }, // Velocidade
            { wch: 10 }  // Tempo
        ];

        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Dados Completos");

        XLSX.writeFile(wb, `dados_completos_${new Date().toISOString().slice(0, 10)}.xlsx`);
    }

    function downloadChart(chartId) {
        const canvas = document.getElementById(chartId);
        const link = document.createElement("a");
        link.href = canvas.toDataURL("image/png");
        link.download = `${chartId}_${document.getElementById('route_id').value}.png`;
        link.click();

        // Adicione esta função no início do script
        function preverVelocidades(dados, passosFuturos = 5) {
            const n = dados.length;
            const sumX = dados.reduce((acc, _, i) => acc + i, 0);
            const sumY = dados.reduce((acc, val) => acc + val, 0);
            const sumXY = dados.reduce((acc, val, i) => acc + (i * val), 0);
            const sumXX = dados.reduce((acc, _, i) => acc + (i * i), 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Prever próximos valores
            const previsoes = [];
            for(let i = n; i < n + passosFuturos; i++) {
                previsoes.push(intercept + slope * i);
            }
            
            return {
                slope,
                intercept,
                previsoes
            };
        }

        // Modifique a seção de análise dinâmica para incluir as previsões
        let analysisHTML = `
            <h4 class="mt-4 text-center">Análise de Desempenho por Período</h4>
            <div class="alert alert-info">
                Média geral do período selecionado: <strong>${overallAvg.toFixed(1)} km/h</strong><br>
                Classificação baseada no desempenho relativo ao período
            </div>`;

        // Adicione esta seção antes da análise por período
        if(velocidades.length > 10) { // Só mostra previsão se tiver dados suficientes
            const previsao = preverVelocidades(velocidades);
            const ultimaData = new Date(labels[labels.length - 1]);
            
            analysisHTML += `
            <div class="alert alert-warning mt-3">
                <h5>Previsão para as próximas horas:</h5>
                <div class="row">`;
            
            previsao.previsoes.forEach((v, i) => {
                const novaData = new Date(ultimaData);
                novaData.setHours(novaData.getHours() + (i + 1));
                
                analysisHTML += `
                    <div class="col-md-2 mb-2">
                        <div class="card">
                            <div class="card-body text-center">
                                <small>${novaData.toLocaleTimeString('pt-BR')}</small>
                                <div class="h5">${v.toFixed(1)} km/h</div>
                            </div>
                        </div>
                    </div>`;
            });
            
            analysisHTML += `</div></div>`;
        }

        // Adicione esta função para mostrar a linha de tendência nos gráficos
        function adicionarLinhaTendencia(chart, previsao, cor) {
            const dadosCompleto = [...velocidades, ...previsao.previsoes];
            
            chart.data.datasets.push({
                label: 'Tendência Prevista',
                data: dadosCompleto,
                borderColor: cor,
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                pointRadius: 0
            });
            
            chart.update();
        }

        // Modifique a criação dos gráficos para incluir a tendência
        const previsaoVelocidade = preverVelocidades(velocidades);
        const chartVelocidade = new Chart(...); // Mantenha o código existente
        adicionarLinhaTendencia(chartVelocidade, previsaoVelocidade, '#FFA500');

        // Adicione esta verificação na análise de status
        if(previsaoVelocidade.slope < -2) {
            statusHTML = `
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> 
                Tendência de redução de velocidade detectada: 
                ${Math.abs(previsaoVelocidade.slope.toFixed(2))} km/h por hora
            </div>` + statusHTML;
        }

    }
</script>
