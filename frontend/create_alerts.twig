<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.6.0/leaflet.polylineDecorator.min.js"></script>
<div class="container mt-4 mb-4">
    <div class="row">
        <div class="col-lg-6 mb-3">
            <h3 class="text-primary">Criar Alerta</h3>
        </div>
    </div>
    <div class="row">
        <div class="col-lg-8">
            <div class="card shadow-sm p-4">
                <form action="api.php?action=cadastrar_evento" method="post" id="eventoForm">

                    <div>
                        <input type="hidden" name="id_parceiro" value="{{ id_parceiro }}">
                    </div>

                    <div class="mb-3">
                        <label for="nome" class="form-label">Descri√ß√£o do Evento</label>
                        <input type="text" class="form-control" id="nome" name="nome" required
                            placeholder="Escreva uma descri√ß√£o breve do Evento" maxlength="250">
                    </div>

                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="tipo" class="form-label">Tipo</label>
                            <select class="form-select" id="tipo" name="tipo" required>
                                <option value="">Selecione um Tipo</option>
                                {% for tipo in tipos %}
                                <option value="{{ tipo.id }}">{{ tipo.name }}</option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-6">
                            <label for="subtipo" class="form-label">Subtipo</label>
                            <select class="form-select" id="subtipo" name="subtipo" required>
                                <option value="">Selecione um Subtipo</option>
                            </select>
                        </div>
                    </div>

                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="starttime" class="form-label">Data de In√≠cio</label>
                            <input type="date" id="starttime" class="form-control" name="starttime">
                        </div>
                        <div class="col-md-6">
                            <label for="endtime" class="form-label">Data de T√©rmino</label>
                            <input type="date" id="endtime" class="form-control" name="endtime">
                        </div>
                    </div>
                    <div id="horarios_dia" class="mb-3">
                        </div>

                    <div class="mb-3">
                        <label for="coordenadas" class="form-label">Coordenadas do Evento (lat, lon)</label>
                        <input type="text" class="form-control" id="coordenadas" name="coordenadas" required
                            placeholder="Clique no mapa para definir as coordenadas" readonly>
                    </div>

                    <div class="mb-3">
                        <label for="rua" class="form-label">Selecione a Rua</label>
                        <select class="form-select" id="ruaSelect" name="rua" required>
                            <option value="">Selecione uma rua</option>
                            </select>
                    </div>

                    <div id="segmentSelectionContainer" class="card shadow-sm p-3 mb-3 border-warning" style="display: none;">
                        <h5 class="text-warning">üì¢ Defina o Segmento da Via</h5>
                        <p class="text-muted small">Clique no mapa para definir a localiza√ß√£o. Selecione abaixo o trecho exato que deseja marcar:</p>
                        <div class="mb-3">
                            <label for="segmentOptions" class="form-label">Escolha o trecho:</label>
                            <select class="form-select" id="segmentOptions" required>
                                </select>
                        </div>
                        <button type="button" id="confirmSegmentBtn" class="btn btn-success mb-2">‚úÖ Confirmar Sele√ß√£o</button>
                        <button type="button" id="cancelSegmentBtn" class="btn btn-secondary btn-sm">Cancelar e Clicar Novamente</button>
                    </div>
                    
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <div class="mb-2">
                                <label for="directionSelect" class="form-label">Escolha o Sentido</label>
                                <select id="directionSelect" class="form-select" name="directionSelect">
                                    </select>
                            </div>
                            <div id="buttonContainer" class="mt-2">
                                </div>

                            {% if id_parceiro == 99 %}
                            <div class="mb-3">
                                <label for="parceiro" class="form-label">Selecione um Parceiro</label>
                                <select class="form-select" id="parceiro" name="id_parceiro_alert" required>
                                    <option value="">Selecione um Parceiro</option>
                                    {% for parceiro in parceiros %}
                                    <option value="{{ parceiro.id }}">{{ parceiro.Nome }}</option>
                                    {% endfor %}
                                </select>
                            </div>
                            {% endif %}

                        </div>
                        <div class="col-md-6 d-flex align-items-end justify-content-end">
                            <button type="submit" class="btn btn-primary">Criar Evento</button>
                        </div>
                    </div>

                </form>
            </div>
        </div>

        <div class="col-lg-4 mt-4 mt-lg-0">
            <div id="map" class="card shadow-sm" style="height: 500px;"></div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf/turf.min.js"></script>
<script>
    // ===== Limpa localstorage =====
    localStorage.clear();
    // ===== Configura√ß√µes Globais =====
    const MAP_CONFIG = {
        SEGMENT_COLORS: {
            original: '#0000ff',
            reversed: '#ff0000',
            both: '#00ff00'
        },
        ARROW_OPTIONS: {
            pixelSize: 15,
            weight: 2
        },
        LOCAL_STORAGE_KEYS: {
            SEGMENT: 'streetSegment',
            DIRECTION: 'segmentDirection'
        }
    };

    // Inicializa calendarios
    flatpickr("#starttime", {
        enableTime: true,
        dateFormat: "Y-m-d H:i", 
        time_24hr: true 
    });
    flatpickr("#endtime", {
        enableTime: true,
        dateFormat: "Y-m-d H:i", 
        time_24hr: true 
    });
    
    // ===== Fun√ß√µes de Inicializa√ß√£o e Localiza√ß√£o =====
    function initializeMap() {
        const map = L.map('map').setView([-23.55052, -46.633308], 15); // Exemplo: S√£o Paulo
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        return map;
    }

    function locateUser(map) {
        map.locate({ setView: true, maxZoom: 12 });
        map.on('locationerror', function (e) {
            alert('N√£o foi poss√≠vel localizar a sua posi√ß√£o.');
        });
    }

    function handleLocationFound(e, map) {
        const radius = e.accuracy / 2;
        L.marker(e.latlng).addTo(map).bindPopup('Voc√™ est√° aqui!').openPopup();
        L.circle(e.latlng, radius).addTo(map);
        console.log('Localiza√ß√£o atual encontrada:', e.latlng);
    }

    // ===== Consulta de Rua e Segmento =====
    function consultarRuaWaze(lat, lon) {
        const url = `api.php?action=get_street&lat_inicio=${lat}&lon_inicio=${lon}`;
        return fetch(url)
            .then(response => response.json())
            .then(data => {
                if (data && data.result && data.result.length > 0) {
                    data.result.sort((a, b) => a.distance - b.distance);
                    return data.result[0].names[0]; // Retorna o nome da rua mais pr√≥xima
                } else {
                    return null;
                }
            })
            .catch(() => null);
    }

    /**
    * Consulta um segmento de rua pr√≥ximo √†s coordenadas informadas.
    */
    async function getStreetSegment(map, lat, lon, drawSegmentCallback) {
        const radiusValues = [50, 100, 200, 300, 500]; 

        for (let radius of radiusValues) {
            const query = `
            [out:json];
            (
                node(around:${radius}, ${lat}, ${lon});
                way(bn)["highway"];
                >;
            );
            out geom;
            `;
            const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.elements && data.elements.length > 0) {
                    const nodes = {};
                    const ways = [];

                    data.elements.forEach(el => {
                        if (el.type === 'node') {
                            nodes[el.id] = [el.lon, el.lat];
                        } else if (el.type === 'way') {
                            ways.push(el);
                        }
                    });

                    let closestWay = null;
                    let minDistance = Infinity;

                    ways.forEach(way => {
                        const wayNodes = way.nodes.map(id => nodes[id]).filter(n => n !== undefined);
                        if (wayNodes.length < 2) return;
                        
                        const distance = turf.pointToLineDistance(turf.point([lon, lat]), turf.lineString(wayNodes), { units: 'meters' });
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestWay = way;
                        }
                    });

                    if (closestWay) {
                        const wayNodes = closestWay.nodes.map(id => nodes[id]).filter(n => n !== undefined);
                        if (wayNodes.length < 2) continue;

                        // Encontrando n√≥s que s√£o pontos de interse√ß√£o com outras vias
                        const intersections = closestWay.nodes.filter(nodeId => 
                            data.elements.some(el => el.type === 'way' && el.id !== closestWay.id && el.nodes && el.nodes.includes(nodeId))
                        );

                        if (intersections.length >= 2) {
                            const intersectionCoords = intersections.map(id => nodes[id]);
                            const nodeMap = wayNodes.reduce((acc, coord, index) => {
                                acc[coord.toString()] = index;
                                return acc;
                            }, {});
                            
                            // Ordenar as interse√ß√µes baseadas na sua posi√ß√£o na way
                            intersections.sort((idA, idB) => {
                                const indexA = closestWay.nodes.indexOf(idA);
                                const indexB = closestWay.nodes.indexOf(idB);
                                return indexA - indexB;
                            });

                            const firstIntersectionIndex = closestWay.nodes.indexOf(intersections[0]);
                            const lastIntersectionIndex = closestWay.nodes.indexOf(intersections[intersections.length - 1]);

                            if (firstIntersectionIndex !== -1 && lastIntersectionIndex !== -1 && firstIntersectionIndex < lastIntersectionIndex) {
                                const segmentNodes = wayNodes.slice(firstIntersectionIndex, lastIntersectionIndex + 1);
                                console.log(`Segmento de intersec√ß√£o encontrado com raio de ${radius} metros.`);
                                promptSegmentSelection(map, { segment: segmentNodes, type: 'intersection' }, lat, lon);
                                return; // Pausa a busca e chama o prompt
                            }
                        }
                        
                        // Se n√£o houver interse√ß√µes suficientes, oferece a via completa
                        console.log(`Via completa oferecida com raio de ${radius} metros.`);
                        promptSegmentSelection(map, { segment: wayNodes, type: 'full' }, lat, lon);
                        return;
                    }
                }
            } catch (error) {
                console.error(`Erro na consulta com raio ${radius}:`, error);
            }
        }
        
        console.warn('Nenhum segmento adequado foi encontrado para os raios testados.');
        showAlert('Nenhum segmento adequado foi encontrado. Tente clicar em outro local.', 'warning');
    }


    // ===== Desenho do Segmento e Controle de Sentido =====
    function drawSegment(segmentNodes, direction = 'both') {
    try {
        // Remove segmento anterior
        if (currentSegmentLayer) {
            map.removeLayer(currentSegmentLayer);
        }

        // Converte coordenadas para [lat, lng]
        const latLngs = segmentNodes.map(coord => [coord[1], coord[0]]);

        // Define estilo baseado na dire√ß√£o
        const color = direction === 'reversed' ? MAP_CONFIG.SEGMENT_COLORS.reversed :
                     direction === 'original' ? MAP_CONFIG.SEGMENT_COLORS.original :
                     MAP_CONFIG.SEGMENT_COLORS.both;

        const lineStyle = { color, weight: 5, opacity: 0.8 };

        // Cria a linha principal
        const segmentLine = L.polyline(latLngs, lineStyle).addTo(map);

        // Adiciona setas de dire√ß√£o
        const arrowDecorator = L.polylineDecorator(segmentLine, {
            patterns: [{
                offset: '50%',
                repeat: '100px',
                symbol: L.Symbol.arrowHead({
                    pixelSize: MAP_CONFIG.ARROW_OPTIONS.pixelSize,
                    polygon: false,
                    pathOptions: lineStyle
                })
            }]
        }).addTo(map);

        // Agrupa as layers
        currentSegmentLayer = L.layerGroup([segmentLine, arrowDecorator]).addTo(map);
        
        // Ajusta o viewport para mostrar o segmento
        map.fitBounds(segmentLine.getBounds(), { padding: [20, 20] });

        // Salva estado
        saveSegmentState(segmentNodes, direction);
        updateDirectionIndicator(direction);
        
        return currentSegmentLayer;
    } catch (error) {
        console.error('Erro ao desenhar segmento:', error);
        showAlert('Erro ao desenhar o segmento no mapa.', 'error');
    }
}

    function updateDirectionControls(direction) {
        const directionSelect = document.getElementById('directionSelect');
        if (directionSelect) {
            directionSelect.value = direction;
        }
        // Exibe ou oculta o bot√£o de revers√£o conforme o sentido
        const reverseBtn = document.getElementById('reverseBtn');
        if (reverseBtn) {
            // O bot√£o de reverter s√≥ faz sentido se o sentido for 'original' ou se for o ponto de partida
            reverseBtn.style.display = (direction === 'original' || direction === 'reversed') ? 'block' : 'none';
        }
    }

    function updateDirectionIndicator(direction) {
        const indicator = document.getElementById('directionIndicator');
        if (indicator) {
            indicator.innerHTML = `
            <span class="badge bg-${direction === 'both' ? 'success' : 'primary'}">
                Sentido selecionado: ${direction.toUpperCase()}
            </span>
        `;
        }
    }

    function saveSegmentState(segment, direction) {
        localStorage.setItem(MAP_CONFIG.LOCAL_STORAGE_KEYS.SEGMENT, JSON.stringify(segment));
        localStorage.setItem(MAP_CONFIG.LOCAL_STORAGE_KEYS.DIRECTION, direction);
    }

    function loadSavedSegment(map) {
        const savedSegment = localStorage.getItem(MAP_CONFIG.LOCAL_STORAGE_KEYS.SEGMENT);
        const savedDirection = localStorage.getItem(MAP_CONFIG.LOCAL_STORAGE_KEYS.DIRECTION);

        if (savedSegment && savedDirection) {
            drawSegment(map, JSON.parse(savedSegment), savedDirection);
            updateDirectionControls(savedDirection);
        }
    }

    // ===== Fun√ß√µes para Inverter Coordenadas =====
    function inverterCoordenadas(segmentNodes, map, currentDirection) {
        const reversedSegment = [...segmentNodes].reverse();
        // Se o sentido atual for 'original', a revers√£o se torna 'reversed', e vice-versa.
        const newDirection = (currentDirection === 'reversed' ? 'original' : 'reversed');
        drawSegment(map, reversedSegment, newDirection);
        saveSegmentState(reversedSegment, newDirection);
        return reversedSegment;
    }

    // ===== Fun√ß√µes Auxiliares =====
    function showAlert(message, type = 'info') {
        const alert = document.createElement('div');
        alert.className = `alert alert-${type} alert-dismissible fade show`;
        alert.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
        document.body.prepend(alert);

        setTimeout(() => alert.remove(), 5000);
    }

    function calcularDiasSemana() {
        // ... (Fun√ß√£o de c√°lculo de dias mantida como estava) ...
        const startDateStr = document.getElementById('starttime').value;
        const endDateStr = document.getElementById('endtime').value;

        if (!startDateStr || !endDateStr) {
            return;
        }

        const start = new Date(startDateStr);
        const end = new Date(endDateStr);

        if (start > end) {
            showAlert('A data de in√≠cio deve ser anterior ou igual √† data de t√©rmino.', 'warning');
            return;
        }

        const diasSemana = new Set();
        const dias = ['Domingo', 'Segunda-feira', 'Ter√ßa-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'S√°bado'];

        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
            diasSemana.add(dias[d.getDay()]);
        }

        atualizarHorarios([...diasSemana]);
    }

    function atualizarHorarios(diasSelecionados) {
        // ... (Fun√ß√£o de atualiza√ß√£o de hor√°rios mantida como estava) ...
        const horariosDiv = document.getElementById('horarios_dia');
        horariosDiv.innerHTML = '';

        const container = document.createElement('div');
        container.className = 'row';

        diasSelecionados.forEach(dia => {
            const col = document.createElement('div');
            col.className = 'col-md-4 mb-3';

            const card = document.createElement('div');
            card.className = 'card';

            const cardBody = document.createElement('div');
            cardBody.className = 'card-body';

            const label = document.createElement('h5');
            label.className = 'card-title';
            label.innerText = dia;

            const inputInicio = document.createElement('input');
            inputInicio.type = 'time';
            inputInicio.name = `${dia.toLowerCase()}_inicio`;
            inputInicio.className = 'form-control mb-2';

            const inputFim = document.createElement('input');
            inputFim.type = 'time';
            inputFim.name = `${dia.toLowerCase()}_fim`;
            inputFim.className = 'form-control';

            cardBody.appendChild(label);
            cardBody.appendChild(inputInicio);
            cardBody.appendChild(inputFim);
            card.appendChild(cardBody);
            col.appendChild(card);
            container.appendChild(col);
        });

        horariosDiv.appendChild(container);
    }

    function carregarSubtiposPorTipo(tipoSelect, subtipoSelect, subtiposPorTipo) {
        // ... (Fun√ß√£o de carregamento de subtipos mantida como estava) ...
        subtipoSelect.innerHTML = '<option value="">Selecione um Subtipo</option>';
        const selectedTipoId = tipoSelect.value;
        if (selectedTipoId && subtiposPorTipo[selectedTipoId]) {
            subtipoSelect.disabled = false;
            subtipoSelect.value = ""; // Reset
            subtiposPorTipo[selectedTipoId].forEach(subtipo => {
                const option = document.createElement('option');
                option.value = subtipo.subtype_value;
                option.textContent = subtipo.name;
                subtipoSelect.appendChild(option);
            });
        } else {
            subtipoSelect.disabled = true;
        }
    }

    // ===== Atualiza√ß√£o de Dire√ß√µes =====
    function atualizarDirecoes(selectElement) {
        // ... (Fun√ß√£o de atualiza√ß√£o de dire√ß√µes mantida como estava) ...
        selectElement.innerHTML = ''; // Limpar op√ß√µes existentes
        const options = [
            { value: 'both', text: 'Ambos os sentidos' },
            { value: 'original', text: 'Sentido original' },
            { value: 'single', text: 'Sentido √∫nico' },
        ];
        options.forEach(optionData => {
            const option = document.createElement('option');
            option.value = optionData.value;
            option.textContent = optionData.text;
            selectElement.appendChild(option);
        });
    }

    // ===== Gerenciamento do Bot√£o de Revers√£o =====
    function mostrarBotaoReverso(segmentNodes, map) {
        let reverseBtn = document.getElementById('reverseBtn');
        if (!reverseBtn) {
            // Cria o bot√£o se n√£o existir
            reverseBtn = document.createElement('button');
            reverseBtn.id = 'reverseBtn';
            reverseBtn.className = 'btn btn-warning mt-2';
            // Usa √≠cone Font Awesome, verifique se a biblioteca est√° carregada no seu HTML!
            reverseBtn.innerHTML = '<i class="fas fa-exchange-alt me-2"></i>Inverter Sentido'; 
            document.getElementById('buttonContainer').appendChild(reverseBtn);
        }
        reverseBtn.style.display = 'block';
        reverseBtn.type = "button";
        reverseBtn.onclick = () => {
            // Obt√©m o sentido atual salvo (se n√£o existir, assume "original")
            const currentDirection = localStorage.getItem(MAP_CONFIG.LOCAL_STORAGE_KEYS.DIRECTION) || 'original';
            // Inverte o segmento e desenha com a dire√ß√£o oposta
            inverterCoordenadas(segmentNodes, map, currentDirection);
        };
    }

    function esconderBotaoReverso() {
        const reverseBtn = document.getElementById('reverseBtn');
        if (reverseBtn) {
            reverseBtn.style.display = 'none';
        }
    }

    // ===== NOVO: Gerenciamento do Painel de Sele√ß√£o de Segmento =====
    function promptSegmentSelection(map, segmentData, lat, lon) {
        const container = document.getElementById('segmentSelectionContainer');
        const optionsSelect = document.getElementById('segmentOptions');
        const confirmBtn = document.getElementById('confirmSegmentBtn');
        const cancelBtn = document.getElementById('cancelSegmentBtn');

        // Limpar e preparar
        optionsSelect.innerHTML = '';
        container.style.display = 'block'; // Mostrar o cont√™iner

        // Salvar dados temporariamente para uso posterior
        container.dataset.lat = lat;
        container.dataset.lon = lon;
        container.dataset.segmentJson = JSON.stringify(segmentData.segment);
        container.dataset.segmentType = segmentData.type;

        // Op√ß√£o 1: Segmento encontrado (entre interse√ß√µes)
        if (segmentData.type === 'intersection') {
            const opt1 = document.createElement('option');
            opt1.value = 'intersection';
            opt1.textContent = 'Trecho entre Interse√ß√µes (Recomendado)';
            optionsSelect.appendChild(opt1);
        }

        // Op√ß√£o 2: Via Completa
        const opt2 = document.createElement('option');
        opt2.value = 'full';
        opt2.textContent = 'Via Completa (Todos os n√≥s encontrados)';
        optionsSelect.appendChild(opt2);
        
        optionsSelect.value = segmentData.type; // Define o padr√£o para o que a API retornou

        // Remover listeners antigos para evitar duplica√ß√£o
        const confirmHandler = confirmBtn.onclick;
        if (confirmHandler) confirmBtn.onclick = null; // Desvincula o anterior, se houver

        // Adicionar novo listener de confirma√ß√£o
        confirmBtn.onclick = () => {
            const selectedType = optionsSelect.value;
            let nodesToDraw;

            if (selectedType === 'intersection' && segmentData.type === 'intersection') {
                nodesToDraw = segmentData.segment;
            } else {
                // Usar a geometria completa se a op√ß√£o 'full' for escolhida
                nodesToDraw = segmentData.segment; 
            }

            if (nodesToDraw && nodesToDraw.length > 1) {
                currentSegmentNodes = nodesToDraw;
                const selectedDirection = document.getElementById('directionSelect').value;
                currentSegmentLayer = drawSegment(map, nodesToDraw, selectedDirection);
                saveSegmentState(nodesToDraw, selectedDirection);
                
                // Ocultar o seletor ap√≥s confirma√ß√£o
                container.style.display = 'none';
                showAlert(`Segmento confirmado com ${nodesToDraw.length} n√≥s.`, 'success');
            } else {
                showAlert('N√£o foi poss√≠vel confirmar o segmento.', 'danger');
            }
        };
        
        // Listener para cancelar e for√ßar um novo clique
        cancelBtn.onclick = () => {
            container.style.display = 'none';
            showAlert('Selecione novamente clicando no mapa.', 'info');
            // Limpa a camada anterior para que o usu√°rio possa clicar de novo
            if (window.currentSegmentLayer) {
                map.removeLayer(window.currentSegmentLayer);
                window.currentSegmentLayer = null;
                currentSegmentNodes = [];
            }
        };
    }

    // ===== Execu√ß√£o Principal =====
    document.addEventListener('DOMContentLoaded', function () {
        const map = initializeMap();
        let currentSegmentNodes = []; // Armazena os n√≥s do segmento atual
        let currentSegmentLayer = null; // Armazena a camada atual do segmento
        const directionSelect = document.getElementById('directionSelect');

        // Carregar segmento salvo (se houver)
        loadSavedSegment(map);

        // Localiza√ß√£o do usu√°rio
        map.on('locationfound', (e) => handleLocationFound(e, map));
        locateUser(map);

        // Evento de clique no mapa: captura coordenadas, consulta rua e SEGMENTO (agora chama prompt)
        map.on('click', (e) => {
            // Se o painel de sele√ß√£o estiver aberto, ignora o clique do mapa
            if (document.getElementById('segmentSelectionContainer').style.display === 'block') {
                return; 
            }
            
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            console.log(`Latitude: ${lat}, Longitude: ${lon}`);

            // Atualiza campo de coordenadas (se existir)
            const coordenadasInput = document.getElementById('coordenadas');
            if (coordenadasInput) {
                coordenadasInput.value = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
            }

            // Consulta o nome da rua via Waze (se aplic√°vel)
            consultarRuaWaze(lat, lon).then(nomeRuaWaze => {
                if (nomeRuaWaze) {
                    const ruaSelect = document.getElementById('ruaSelect');
                    if (ruaSelect) {
                        ruaSelect.innerHTML = ''; 
                        const option = document.createElement('option');
                        option.value = nomeRuaWaze;
                        option.textContent = nomeRuaWaze;
                        ruaSelect.appendChild(option);
                        ruaSelect.value = nomeRuaWaze; // Seleciona automaticamente
                    }
                }
            });

            // Consulta o segmento de rua pr√≥ximo e chama o prompt de sele√ß√£o
            getStreetSegment(map, lat, lon, (segmentNodes) => {
                // O desenho agora √© feito dentro de promptSegmentSelection/confirmar
                // Este callback apenas garante que currentSegmentNodes seja atualizado antes da sele√ß√£o final, se necess√°rio.
                if (segmentNodes && segmentNodes.length > 1) {
                    currentSegmentNodes = segmentNodes;
                    // Se o desenho fosse imediato, seria: drawSegment(map, segmentNodes, directionSelect.value);
                } else {
                    console.warn('Nenhum segmento v√°lido retornado pela consulta.');
                }
            });
        });

        // Atualiza o select de sentido
        if (directionSelect) {
            atualizarDirecoes(directionSelect);
        }

        // Evento para altera√ß√£o do sentido via select
        if (directionSelect) {
            directionSelect.addEventListener('change', (e) => {
                const selectedDirection = e.target.value;
                console.log('Dire√ß√£o selecionada:', selectedDirection);
                if (currentSegmentNodes && currentSegmentNodes.length > 1) {
                    currentSegmentLayer = drawSegment(map, currentSegmentNodes, selectedDirection);
                    saveSegmentState(currentSegmentNodes, selectedDirection);
                    
                    // Mostra ou esconde o bot√£o de revers√£o conforme o sentido
                    if (selectedDirection === 'single') {
                        mostrarBotaoReverso(currentSegmentNodes, map);
                    } else {
                        esconderBotaoReverso();
                    }
                }
            });
        }

        // Eventos para agendamento
        const starttimeInput = document.getElementById('starttime');
        const endtimeInput = document.getElementById('endtime');
        if (starttimeInput && endtimeInput) {
            starttimeInput.addEventListener('change', calcularDiasSemana);
            endtimeInput.addEventListener('change', calcularDiasSemana);
        }

        // Carregamento de subtipos conforme o tipo selecionado
        const tipoSelect = document.getElementById('tipo');
        const subtipoSelect = document.getElementById('subtipo');
        // A vari√°vel {{ subtiposPorTipo | json_encode | raw }} √© esperada aqui
        const subtiposPorTipo = {{ subtiposPorTipo | json_encode | raw }}; 
        if (tipoSelect && subtipoSelect) {
            tipoSelect.addEventListener('change', () => carregarSubtiposPorTipo(tipoSelect, subtipoSelect, subtiposPorTipo));
        }
    });

    document.addEventListener('DOMContentLoaded', function (event) {
        const eventoForm = document.getElementById('eventoForm');
        const submitBtn = document.querySelector('button[type="submit"]');

        if (eventoForm && submitBtn) {
            eventoForm.addEventListener('submit', function (e) {
                e.preventDefault(); // Interrompe o envio padr√£o

                // Verifica se um segmento foi selecionado antes de enviar
                const segment = localStorage.getItem('streetSegment');
                const direction = localStorage.getItem('segmentDirection');

                if (!segment || !direction) {
                    showAlert('Por favor, clique no mapa para selecionar e confirmar o trecho da via antes de enviar.', 'error');
                    // Opcional: Focar o mapa ou rolar at√© ele
                    return; 
                }

                const formData = new FormData(eventoForm);

                // Adiciona os dados do localStorage ao FormData
                formData.append('streetSegment', segment);
                formData.append('segmentDirection', direction);
                
                // Envia os dados usando fetch.
                fetch(eventoForm.action, {
                    method: 'POST',
                    body: formData
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Erro na requisi√ß√£o: ' + response.status);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log("Resposta do servidor:", data);
                        if (data.success) {
                            // Limpa o estado do mapa ap√≥s sucesso para evitar confus√£o em um novo cadastro
                            localStorage.clear(); 
                            window.location.href = "https://wfcbrasil.com.br/create_alerts"; // Redireciona
                        } else {
                            showAlert(data.message || "Ocorreu um erro no envio dos dados.", 'danger');
                        }
                    })
                    .catch(error => {
                        console.error("Erro ao enviar os dados:", error);
                        showAlert("Falha na comunica√ß√£o com o servidor.", 'danger');
                    });
            });
        } else {
            console.error("Formul√°rio ou bot√£o de envio n√£o encontrado.");
        }
    });
</script>


<style>
    /* Estilos Aprimorados */
    #map {
        border-radius: 8px;
        transition: box-shadow 0.3s ease;
        height: 400px; /* Altura padr√£o */
    }

    /* Em dispositivos m√≥veis, reduzir a altura do mapa */
    @media (max-width: 768px) {
        #map {
            height: 300px;
        }
    }

    #map:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .leaflet-popup-content {
        font-size: 14px;
        padding: 8px;
    }

    .btn-warning {
        background-color: #ffc107;
        border-color: #ffc107;
        transition: all 0.3s ease;
    }

    .btn-warning:hover {
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3);
    }

    /* Estilo para o novo painel de sele√ß√£o */
    #segmentSelectionContainer {
        border-left: 5px solid #ffc107 !important; /* Cor de destaque */
    }

    /* Ajustes de responsividade para os cards de hor√°rios */
    @media (max-width: 576px) {
        .card .row .col-md-4 {
            flex: 0 0 100%;
            max-width: 100%;
        }
    }
</style>