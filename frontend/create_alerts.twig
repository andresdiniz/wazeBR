<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.6.0/leaflet.polylineDecorator.min.js"></script>
<div class="container mt-4 mb-4">
    <div class="row">
        <div class="col-lg-6 mb-3">
            <h3 class="text-primary">Criar Alerta</h3>
        </div>
    </div>
    <div class="row">
        <div class="col-lg-8">
            <div class="card shadow-sm p-4">
                <form action="api.php?action=cadastrar_evento" method="post" id="eventoForm">

    
                    <div>
                        <input type="hidden" name="id_parceiro" value="{{ id_parceiro }}">
                        <input type="hidden" id="finalPolylineInput" name="coordenadas" required>
                        <input type="hidden" id="finalStreetNameInput" 
name="rua" required>

                    </div>

                    <div class="mb-3">
                        <label for="nome" class="form-label">Descri√ß√£o do Evento</label>
                        <input type="text" class="form-control" id="nome" name="nome" required
 
                           placeholder="Escreva uma descri√ß√£o breve do Evento" maxlength="250">
                    </div>

                    <div class="row mb-3">
                        <div 
class="col-md-6">
                            <label for="tipo" class="form-label">Tipo</label>
                            <select class="form-select" id="tipo" name="tipo" required>
                                <option value="">Selecione um Tipo</option>
   
                             {% for tipo in tipos %}
                                    <option value="{{ tipo.id }}">{{ tipo.name }}</option>
                         
        {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-6">
              
               <label for="subtipo" class="form-label">Subtipo</label>
                            <select class="form-select" id="subtipo" name="subtipo" required disabled>
                                <option value="">Selecione um Subtipo</option>
                
             </select>
                        </div>
                    </div>

                    <div class="row mb-3">
                      
    <div class="col-md-6">
                            <label for="starttime" class="form-label">Data de In√≠cio</label>
                            <input type="date" id="starttime" class="form-control" name="starttime">
                        </div>
         
                <div class="col-md-6">
                            <label for="endtime" class="form-label">Data de T√©rmino</label>
                            <input type="date" id="endtime" class="form-control" name="endtime">
                    
      </div>
                    </div>
                    <div id="horarios_dia" class="mb-3">
                    </div>

                    <div class="mb-3">
             
               <label for="coordenadas" class="form-label">Coordenadas do Evento (lat, lon)</label>
                        <input type="text" class="form-control" id="coordenadas" name="coordenadas_inicial" required
                            placeholder="Clique no mapa para definir as coordenadas" readonly>
                   
   </div>
                    
                    <div id="segmentSelectionContainer" class="card shadow-sm p-3 mb-3 border-warning" style="display: none;">
                        <h5 class="text-warning">üì¢ Defina o Segmento da Via</h5>
                        <p class="text-muted small">Clique no mapa para definir a localiza√ß√£o.
 Selecione abaixo o trecho exato que deseja marcar:</p>
                        <div class="mb-3">
                            <label for="segmentOptions" class="form-label">Escolha o trecho:</label>
                            <select class="form-select" id="segmentOptions" >
     
                         </select>
                        </div>
                        <button type="button" id="confirmSegmentBtn" class="btn btn-success mb-2">‚úÖ Confirmar Sele√ß√£o</button>
                      
    <button type="button" id="cancelSegmentBtn" class="btn btn-secondary btn-sm">Cancelar e Clicar Novamente</button>
                    </div>
                    
                    <div class="row mb-3">
                        <div class="col-md-6">
   
                             <div class="mb-2">
                                <label for="directionSelect" class="form-label">Escolha o Sentido</label>
                                <select id="directionSelect" 
    
                                 class="form-select" name="segmentDirection" required>
                                </select>
                            </div>
       
                         <div id="buttonContainer" class="mt-2">
                            </div>

                            {% if id_parceiro == 99 %}
                
             <div class="mb-3">
                                <label for="parceiro" class="form-label">Selecione um Parceiro</label>
                                <select class="form-select" id="parceiro" name="id_parceiro_alert" required>
               
                         <option value="">Selecione um Parceiro</option>
                                    {% for parceiro in parceiros %}
                                   
   <option value="{{ parceiro.id }}">{{ parceiro.Nome }}</option>
                                    {% endfor %}
                                </select>
                        
      </div>
                            {% endif %}

                        </div>
                        <div class="col-md-6 d-flex align-items-end justify-content-end">
              
               <button type="submit" class="btn btn-primary">Criar Evento</button>
                        </div>
                    </div>

                </form>
            </div>
        </div>

  
        <div class="col-lg-4 mt-4 mt-lg-0">
            <div id="map" class="card 
                shadow-sm" style="height: 500px;"></div>
        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf/turf.min.js"></script>

<script>
// ==========================================================
        // >> NOVO C√ìDIGO PARA ENVIO AJAX DO FORMUL√ÅRIO <<
        // ==========================================================
        const form = document.getElementById('eventoForm');
if (form) {
            form.addEventListener('submit', async function(e) {
                e.preventDefault(); // Impede o envio padr√£o do formul√°rio

                const formData = new FormData(this);
                const actionUrl = this.action;

                try {
                    const response = await fetch(actionUrl, {
                        method: 'POST',
                        body: formData
                    });

                    // Tenta processar a resposta como JSON
                    const result = await response.json(); 

                    if (response.ok && result.success) { // Status 200 e sucesso
                        showAlert(result.message, 'success');
                        
                        // Recarrega a p√°gina ap√≥s 1.5 segundo para o usu√°rio ver o alerta
                        setTimeout(() => {
                            window.location.reload(); 
                        }, 1500);
                        
                    } else { // Status de erro (400, 500) ou sucesso: false
                        let errorMessage = result.message ||
result.error || 'Erro desconhecido ao processar o evento.';
                        
                        // Adiciona campos faltantes na mensagem de erro se houver
                        if (result.missing && Array.isArray(result.missing)) {
                            errorMessage += '<br>Campos faltantes: ' + result.missing.join(', ');
                        }
                        
                        showAlert(errorMessage, 'danger');
                    }

                } catch (error) {
                    console.error('Erro de rede ou ao processar JSON:', error);
showAlert('N√£o foi poss√≠vel se conectar ao servidor ou a resposta √© inv√°lida.', 'danger');
                }
            });
        }
const SUBTIPOS_POR_TIPO = {{ subtiposPorTipo |
json_encode() | raw }};
    // ===== Vari√°veis Globais =====
    let map;
    let currentSegmentNodes = [];
let currentSegmentLayer = null;
    let clickMarker = null;

    // Limpa o localStorage para evitar dados de sess√µes anteriores
    localStorage.clear();
// ===== Configura√ß√µes Globais =====
    const MAP_CONFIG = {
        SEGMENT_COLORS: {
            original: '#0000ff',
            reversed: '#ff0000',
            both: '#00ff00'
        },
        ARROW_OPTIONS: {
            pixelSize: 15,
            weight: 2
        },
        LOCAL_STORAGE_KEYS: {
            SEGMENT: 'streetSegment',
            DIRECTION: 'segmentDirection'
        }
    };
// Inicializa calendarios (Flatpickr)
    flatpickr("#starttime", {
        enableTime: true,
        dateFormat: "Y-m-d H:i", 
        time_24hr: true 
    });
flatpickr("#endtime", {
        enableTime: true,
        dateFormat: "Y-m-d H:i", 
        time_24hr: true 
    });
// ===== Fun√ß√µes de Inicializa√ß√£o e Localiza√ß√£o =====
    function initializeMap() {
        // Coordenadas padr√£o para o Brasil se a localiza√ß√£o falhar
        map = L.map('map').setView([-23.55052, -46.633308], 15);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
return map;
    }

    function locateUser(map) {
        map.locate({ setView: true, maxZoom: 12 });
map.on('locationerror', function (e) {
            showAlert('N√£o foi poss√≠vel localizar a sua posi√ß√£o.', 'warning');
        });
map.on('locationfound', function(e) { handleLocationFound(e, map); });
    }

    function handleLocationFound(e, map) {
        const radius = e.accuracy / 2;
L.marker(e.latlng).addTo(map).bindPopup('Voc√™ est√° aqui!').openPopup();
        L.circle(e.latlng, radius).addTo(map);
    }
    
    // =========================================================================
// MODIFICA√á√ÉO PRINCIPAL: L√≥gica condicional no clique do mapa
// =========================================================================
function handleMapClick(e) {
    const { lat, lng } = e.latlng;
    const tipoSelect = document.getElementById('tipo');
    const tipoId = tipoSelect ? tipoSelect.value : '';
    // Limpa camadas anteriores
    if (clickMarker) {
        map.removeLayer(clickMarker);
    }
    if (currentSegmentLayer) {
        map.removeLayer(currentSegmentLayer);
        currentSegmentLayer = null;
    }

    clickMarker = L.marker([lat, lng]).addTo(map);

    // Passo 1: Limpa os campos de submiss√£o finais (incluindo a polylinha) a cada clique
    document.getElementById('finalPolylineInput').value = '';
    document.getElementById('finalStreetNameInput').value = '';
    
    // ** Condi√ß√£o para ativar a l√≥gica de segmento apenas para o tipo 6 **
    if (tipoId === '6') {
        // Se for Tipo 6 (Segmento), limpamos o campo 'coordenadas'
        // para evitar que o ponto √∫nico interfira no envio da polylinha.
        document.getElementById('coordenadas').value = ''; 
        
        // Tipo 6 (Ex: Rodovias): Usa a l√≥gica completa de sele√ß√£o de segmento
        getStreetSegment(map, lat, lng);
    } else {
        // Outros Tipos: Usa a l√≥gica simplificada de ponto √∫nico.
        // O campo 'coordenadas' recebe o ponto, e handleSimpleClick garante que
        // 'finalPolylineInput' tamb√©m receba esse ponto.
        document.getElementById('coordenadas').value = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;

        // ** CORRE√á√ÉO 2: Garante que a l√≥gica simplificada seja chamada para tipos n√£o-segmento **
        handleSimpleClick(map, lat, lng);
    }
}
// =========================================================================
    // =========================================================================

    // Fun√ß√£o auxiliar para buscar apenas o nome da rua (simplificada)
    async function getStreetName(lat, lon) {
        const radiusValues = [50, 100, 200];
        // Raio de busca crescente
        let streetName = 'Nome da Rua Desconhecido';
        for (let radius of radiusValues) {
            const query = `
            [out:json];
            way(around:${radius}, ${lat}, ${lon})["highway"];
            out tags;
            `;
            const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.elements && data.elements.length > 0) {
                    const closestWay = data.elements.find(el => el.type === 'way' && el.tags && el.tags.name);
                    if (closestWay) {
                        streetName = closestWay.tags.name;
                        break; // Encontrou o nome, pode sair
                    }
                }
            } catch (error) {
                console.error(`Erro na consulta Overpass para nome (${radius}):`, error);
            }
        }
        return streetName;
    }

    // Nova fun√ß√£o para lidar com clique simples (apenas coordenada e nome da rua)
    async function handleSimpleClick(map, lat, lon) {
        // 1. Oculta o painel de sele√ß√£o de segmento e o bot√£o reverso
        document.getElementById('segmentSelectionContainer').style.display = 'none';
        esconderBotaoReverso();
        
        // 2. Busca o nome da rua
        const streetName = await getStreetName(lat, lon);
        // 3. Define a coordenada √∫nica como a "polyline" final
        // Formato Waze/final: lat,lon (ponto √∫nico)
        const polylineWazeFormat = `${lat.toFixed(5)},${lon.toFixed(5)}`;
        // 4. Preenche os campos de submiss√£o (hidden fields)
        document.getElementById('finalPolylineInput').value = polylineWazeFormat;
        document.getElementById('finalStreetNameInput').value = streetName;

        // 5. Atualiza o campo de rua (assumindo que 'ruaSelect' exista)
        const ruaSelect = document.getElementById('ruaSelect');
        if (ruaSelect) {
            ruaSelect.innerHTML = `<option value="${streetName}" selected>${streetName}</option>`;
        }
        
        // 6. Limpa o estado de segmento, j√° que √© um ponto
        localStorage.clear();
        currentSegmentNodes = [];
        
        // 7. Feedback visual
        showAlert(`Localiza√ß√£o confirmada na rua **${streetName}**. Coordenada √∫nica salva.`, 'success');
    }

    // ===== Consulta de Rua e Segmento (CORE da L√≥gica - Usado apenas para Tipo 6) =====
    
    async function getStreetSegment(map, lat, lon) {
        // Raio de busca crescente para encontrar vias menores primeiro
        const radiusValues = [5,25,50, 100, 200, 400, 800, 1200, 2000];
        let streetName = 'Nome da Rua Desconhecido';
        
        // Atualiza estado de busca UI para o Tipo 6
        const ruaSelect = document.getElementById('ruaSelect');
        document.getElementById('segmentSelectionContainer').style.display = 'none';
        esconderBotaoReverso();
for (let radius of radiusValues) {
            // Consulta Overpass: busca vias ("way") e n√≥s ("node") ao redor
            const query = `
            [out:json];
            (
                way(around:${radius}, ${lat}, ${lon})["highway"];
                node(w);
            );
            out geom;
            `;
            
            const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.elements && data.elements.length > 0) {
                    const allWays = data.elements.filter(el => el.type === 'way' && el.tags && el.tags.highway);
                    let closestWay = null;
                    let minDistance = Infinity;

                    // 1. Encontra a via mais pr√≥xima do clique
                    allWays.forEach(way => {
                        if (!way.tags.name || !way.geometry || way.geometry.length < 2) return;
                        
      
                        const wayCoords = way.geometry.map(g => [g.lon, g.lat]);
                        const distance = turf.pointToLineDistance(turf.point([lon, lat]), turf.lineString(wayCoords), { units: 'meters' });
                        
                  
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestWay = way;
                        }
  
                    });
                    if (closestWay) {
                        const fullWayGeometry = closestWay.geometry.map(g => [g.lon, g.lat]);
                        // [lon, lat]
                        streetName = closestWay.tags.name ||
                            'Nome da Rua Desconhecido';
                        
                        // 2. Tenta identificar o segmento delimitado por intersec√ß√µes
                        const wayNodes = closestWay.nodes;
                        const intersectionNodeIds = [];
                        const nodeUsageCount = {};
                        
                        // Conta quantas vias compartilham cada n√≥ (identifica intersec√ß√µes)
                        data.elements.filter(el => el.type === 'way' && el.id !== closestWay.id && el.nodes)
                            .forEach(otherWay => {
                    
                                otherWay.nodes.forEach(nodeId => {
                                    if (wayNodes.includes(nodeId)) {
                                        nodeUsageCount[nodeId] = (nodeUsageCount[nodeId] || 0) + 1;
 
                                    }
                                });
                            });
                        // Adiciona ao array apenas os n√≥s que s√£o pontos de intersec√ß√£o real
                        wayNodes.forEach(nodeId => {
                            if (nodeUsageCount[nodeId] >= 1) {
                              
                                intersectionNodeIds.push(nodeId);
                            }
                        });
                        let segmentNodes = [];
                        
                        // Se houver pelo menos duas intersec√ß√µes para delimitar um segmento
                        if (intersectionNodeIds.length >= 2) {
                            
                            // Encontra 
                            const intersectionIndexes = intersectionNodeIds.map(id => {
                                const node = data.elements.find(el => el.type === 'node' && el.id === id);
              
                                    if (node) {
                                    // Procura o √≠ndice do ponto mais pr√≥ximo (lon, lat) na geometria completa
                              
                                        return fullWayGeometry.findIndex(coord => coord[0] === node.lon && coord[1] === node.lat);
                                    }
                                    return -1;
                  
                            }).filter(i => i !== -1).sort((a,b) => a - b);
                            
                            if (intersectionIndexes.length >= 2) {
                                const clickPoint = turf.point([lon, lat]);
                                let closestIntersectionIndex = -1;
                                let minDistanceToIntersection = Infinity;

                                // Identifica qual segmento (entre intersec√ß√µes) foi clicado
                                for (let i = 0; i < intersectionIndexes.length - 1; i++) {
                                    const startIndex = intersectionIndexes[i];
                                    const endIndex = intersectionIndexes[i + 1];
                                    
                                    // Cria um LineString do segmento atual
                                    const segmentLine = turf.lineString(fullWayGeometry.slice(startIndex, endIndex + 1));
                                    const distance = turf.pointToLineDistance(clickPoint, segmentLine, { units: 'meters' });

                                    // ** CORRE√á√ÉO 1: Aumenta o limite de toler√¢ncia de 5m para 15m **
                                    // Se o clique estiver dentro de um limiar razo√°vel e for o mais pr√≥ximo at√© agora
                                    if (distance < 15 && distance < minDistanceToIntersection) { 
                              
                                        minDistanceToIntersection = distance;
                                        closestIntersectionIndex = i;
                                        // Garante que o trecho seja entre essas duas intersec√ß√µes
                                        segmentNodes = fullWayGeometry.slice(startIndex, endIndex + 1);
                                    }
                                }
                            }
                        }

                
                        
                        // 3. Oferece sele√ß√£o
                        // Se encontrou um segmento v√°lido entre intersec√ß√µes, usa a op√ß√£o "intersection"
                        if (segmentNodes.length > 1) {
                  
                            promptSegmentSelection(map, { 
                                segment: segmentNodes, 
                                fullWay: fullWayGeometry,
                   
                                type: 'intersection',
                                streetName: streetName
                            }, lat, lon);
                            return;
                        }
                        
                        // 4. Fallback: Se falhar a segmenta√ß√£o por intersec√ß√£o, oferece a via completa
                        promptSegmentSelection(map, { 
             
                            segment: fullWayGeometry, 
                            fullWay: fullWayGeometry, 
                            type: 'full',
                      
                            streetName: streetName
                        }, lat, lon);
                        return;
                    }
                }
            } catch (error) {
                console.error(`Erro na consulta com raio ${radius}:`, error);
            }
        }
        
        // Se a busca falhar
        if (ruaSelect) {
            ruaSelect.innerHTML = '<option value="">Nenhuma rua encontrada</option>';
        }
showAlert('Nenhum segmento adequado foi encontrado. Tente clicar em outro local.', 'warning');
    }
    
    // Fun√ß√£o para carregar subtipos via Fetch (API) - mantida, mas a vers√£o do twig deve ter prioridade
    async function loadSubtypes_old(tipoId) {
        const subtipoSelect = document.getElementById('subtipo');
        subtipoSelect.innerHTML = '<option value="">Carregando Subtipos...</option>';
        subtipoSelect.disabled = true;

        if (!tipoId) {
            subtipoSelect.innerHTML = '<option value="">Selecione um Subtipo</option>';
            return;
        }

        const url = `api.php?action=get_subtipos&id=${tipoId}`;
        try {
            const response = await fetch(url);
            const subtypes = await response.json();

            subtipoSelect.innerHTML = '<option value="">Selecione um Subtipo</option>';
            if (subtypes && subtypes.length > 0) {
                subtypes.forEach(subtipo => {
                    const option = document.createElement('option');
                    option.value = subtipo.id;
                    option.textContent = subtipo.name;
         
                    subtipoSelect.appendChild(option);
                });
                subtipoSelect.disabled = false;
            } else {
                subtipoSelect.innerHTML = '<option value="">Nenhum Subtipo Encontrado</option>';
            }

        } catch (error) {
            console.error('Erro ao buscar subtipos:', error);
            subtipoSelect.innerHTML = '<option value="">Erro ao Carregar Subtipos</option>';
        }
    }


    // ===== Fun√ß√µes de Desenho e Estado (sem altera√ß√µes) =====

    function drawSegment(segmentNodes, direction = 'both') {
        try {
            if (currentSegmentLayer) {
                map.removeLayer(currentSegmentLayer);
            }

            // Converte [lon, lat] para [lat, lon] do Leaflet
            let latLngs = segmentNodes.map(coord => [coord[1], coord[0]]);
            const color = direction === 'reversed' ? MAP_CONFIG.SEGMENT_COLORS.reversed :
                            direction === 'original' ?
MAP_CONFIG.SEGMENT_COLORS.original :
                            MAP_CONFIG.SEGMENT_COLORS.both;
            const lineStyle = { 
                color: color, 
                weight: 5, 
                opacity: 0.8,
                lineCap: 'round',
                lineJoin: 'round'
         
            };

            const segmentLine = L.polyline(latLngs, lineStyle).addTo(map);
            
            let arrowDecorator = null;
            if (direction !== 'both') {
                if (direction === 'reversed') {
                    // Inverte o Polyline para desenhar a seta na dire√ß√£o correta
                    segmentLine.setLatLngs([...latLngs].reverse());
                }

                const arrowOptions = {
                    patterns: [
                        {
                            offset: '50%',
       
                            repeat: '100px',
                            symbol: L.Symbol.arrowHead({
                                pixelSize: MAP_CONFIG.ARROW_OPTIONS.pixelSize,
            
                                polygon: false,
                                pathOptions: {
                                    color: color,
       
                                    weight: MAP_CONFIG.ARROW_OPTIONS.weight,
                                    opacity: 0.8
                                }
 
                            })
                        }
                    ]
                };
                arrowDecorator = L.polylineDecorator(segmentLine, arrowOptions).addTo(map);
            }

            const layersToAdd = [segmentLine];
            if (arrowDecorator) {
                layersToAdd.push(arrowDecorator);
            }
            currentSegmentLayer = L.layerGroup(layersToAdd).addTo(map);
            map.fitBounds(segmentLine.getBounds(), { padding: [20, 20] });
            
            saveSegmentState(segmentNodes, direction);
            updateDirectionControls(direction);
            
            return currentSegmentLayer;
        } catch (error) {
            console.error('Erro ao desenhar segmento:', error);
            showAlert('Erro ao desenhar o segmento no mapa.', 'error');
        }
    }

    function updateDirectionControls(direction) {
        const directionSelect = document.getElementById('directionSelect');
        if (directionSelect) {
            atualizarDirecoes(directionSelect);
            directionSelect.value = direction;
        }
        const reverseBtn = document.getElementById('reverseBtn');
        if (reverseBtn) {
            // O bot√£o de inverter s√≥ √© √∫til se n√£o for 'Ambos os sentidos'
            reverseBtn.style.display = (direction === 'original' || direction === 'reversed') ?
'block' : 'none';
        }
    }

    function saveSegmentState(segment, direction) {
        localStorage.setItem(MAP_CONFIG.LOCAL_STORAGE_KEYS.SEGMENT, JSON.stringify(segment));
        localStorage.setItem(MAP_CONFIG.LOCAL_STORAGE_KEYS.DIRECTION, direction);
    }
    
    function inverterCoordenadas(segmentNodes, map, currentDirection) {
        // Inverter o array de n√≥s
        const reversedSegment = [...segmentNodes].reverse();
        const newDirection = (currentDirection === 'reversed' ? 'original' : 'reversed');
        
        drawSegment(reversedSegment, newDirection);
        
        window.currentSegmentNodes = reversedSegment;
        saveSegmentState(reversedSegment, newDirection);
        document.getElementById('directionSelect').value = newDirection;
        // Atualiza o dataset para a confirma√ß√£o
        const container = document.getElementById('segmentSelectionContainer');
        container.dataset.tempSegmentJson = JSON.stringify(reversedSegment);
        container.dataset.tempSegmentDirection = newDirection;

        return reversedSegment;
    }

    function showAlert(message, type = 'info') {
        const alert = document.createElement('div');
        alert.className = `alert alert-${type} alert-dismissible fade show`;
        alert.style.position = 'fixed';
        alert.style.top = '10px';
        alert.style.right = '10px';
        alert.style.zIndex = '1050';
        alert.innerHTML = `${message}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
        document.body.appendChild(alert);

        setTimeout(() => alert.remove(), 5000);
    }
    
    function atualizarDirecoes(selectElement) {
        selectElement.innerHTML = '';
        const options = [
            { value: 'both', text: 'Ambos os sentidos' },
            { value: 'original', text: 'Sentido original' },
            { value: 'reversed', text: 'Sentido reverso' },
        ];
        options.forEach(optionData => {
            const option = document.createElement('option');
            option.value = optionData.value;
            option.textContent = optionData.text;
            selectElement.appendChild(option);
        });
    }

    function mostrarBotaoReverso(segmentNodes, map) {
        let reverseBtn = document.getElementById('reverseBtn');
        if (!reverseBtn) {
            reverseBtn = document.createElement('button');
            reverseBtn.id = 'reverseBtn';
            reverseBtn.className = 'btn btn-warning mt-2';
            reverseBtn.innerHTML = '<i class="fas fa-exchange-alt me-2"></i>Inverter Sentido';
            document.getElementById('buttonContainer').appendChild(reverseBtn);
        }
        reverseBtn.style.display = 'block';
        reverseBtn.type = "button";
        reverseBtn.onclick = () => {
            const currentDirection = localStorage.getItem(MAP_CONFIG.LOCAL_STORAGE_KEYS.DIRECTION) ||
'original';
            inverterCoordenadas(window.currentSegmentNodes, map, currentDirection);
        };
    }

    function esconderBotaoReverso() {
        const reverseBtn = document.getElementById('reverseBtn');
        if (reverseBtn) {
            reverseBtn.style.display = 'none';
        }
    }
    
    function calcularDiasSemana() {
        // Implemente sua l√≥gica de c√°lculo de dias da semana aqui, se necess√°rio.
    }

    // Gerenciamento do Painel de Sele√ß√£o de Segmento
    function promptSegmentSelection(map, segmentData, lat, lon) {
        const container = document.getElementById('segmentSelectionContainer');
        const optionsSelect = document.getElementById('segmentOptions');
        const confirmBtn = document.getElementById('confirmSegmentBtn');
        const cancelBtn = document.getElementById('cancelSegmentBtn');

        const intersectionSegmentNodes = segmentData.type === 'intersection' ?
segmentData.segment : [];
        const fullSegmentNodes = segmentData.fullWay || segmentData.segment;
        const streetName = segmentData.streetName;
        
        optionsSelect.innerHTML = '';
        container.style.display = 'block';
        let options = [];

        // Op√ß√£o 1: Trecho entre Interse√ß√µes
        if (segmentData.type === 'intersection' && intersectionSegmentNodes.length > 1) {
            // Usa as coordenadas de in√≠cio e fim do segmento para a descri√ß√£o
            const startCoord = `${intersectionSegmentNodes[0][1].toFixed(5)}, ${intersectionSegmentNodes[0][0].toFixed(5)}`;
            const endCoord = `${intersectionSegmentNodes[intersectionSegmentNodes.length - 1][1].toFixed(5)}, ${intersectionSegmentNodes[intersectionSegmentNodes.length - 1][0].toFixed(5)}`;
            
            options.push({ 
                value: 'intersection', 
                text: `Trecho: ${streetName} (De ${startCoord} at√© ${endCoord}) - Selecionado`, 
                nodes: intersectionSegmentNodes 
            });
        }

        // Op√ß√£o 2: Via Completa
        options.push({ value: 'full', text: `Via Completa: ${streetName}`, nodes: fullSegmentNodes });
        options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.text;
            optionsSelect.appendChild(option); // Adiciona ao select
        });
        // Seleciona a melhor op√ß√£o automaticamente
        optionsSelect.value = segmentData.type === 'intersection' ?
'intersection' : 'full';

        function handleSegmentSelection(selectedType) {
            const selectedOption = options.find(opt => opt.value === selectedType);
            if (selectedOption && selectedOption.nodes && selectedOption.nodes.length > 1) {
                const direction = document.getElementById('directionSelect').value ||
'both';
                
                window.currentSegmentLayer = drawSegment(selectedOption.nodes, direction);
                
                // Salva temporariamente no dataset para o clique de confirma√ß√£o
                container.dataset.tempSegmentJson = JSON.stringify(selectedOption.nodes);
                container.dataset.tempSegmentDirection = direction;

                window.currentSegmentNodes = selectedOption.nodes;
                if (direction === 'original' || direction === 'reversed') {
                    mostrarBotaoReverso(window.currentSegmentNodes, map);
                } else {
                    esconderBotaoReverso();
                }
            }
        }
        
        handleSegmentSelection(optionsSelect.value);
        // Desenha a op√ß√£o inicial
        
        // Listener de Mudan√ßa de Op√ß√£o
        optionsSelect.onchange = (e) => {
            handleSegmentSelection(e.target.value);
        };

        // Listener de Confirma√ß√£o: Salva o estado e preenche os campos finais
        confirmBtn.onclick = () => {
            const nodesToDraw = JSON.parse(container.dataset.tempSegmentJson);
            const selectedDirection = container.dataset.tempSegmentDirection;

            if (nodesToDraw && nodesToDraw.length > 1) {
                currentSegmentNodes = nodesToDraw;
                saveSegmentState(nodesToDraw, selectedDirection);
                
                // Formato Waze/final: lat,lon,lat,lon,... 
                const polylineWazeFormat = nodesToDraw.map(coord => `${coord[1]},${coord[0]}`).join(',');
                // Salva nos campos de submiss√£o (hidden fields)
                document.getElementById('finalPolylineInput').value = polylineWazeFormat;
                document.getElementById('finalStreetNameInput').value = streetName;
                
                // A√á√ÉO DE PREENCHIMENTO DO CAMPO 'SELECIONE A RUA'
                const ruaSelect = document.getElementById('ruaSelect');
                if (ruaSelect) {
                    ruaSelect.innerHTML = `<option value="${streetName}" selected>${streetName}</option>`;
                }
                
                container.style.display = 'none';
showAlert(`Segmento confirmado para a rua **${streetName}**. Sentido: **${selectedDirection.toUpperCase()}**`, 'success');
} else {
                showAlert('Erro: Segmento inv√°lido para confirma√ß√£o.', 'danger');
            }
        };
        
        // Listener de Cancelamento
        cancelBtn.onclick = () => {
            if (currentSegmentLayer) {
                map.removeLayer(currentSegmentLayer);
                currentSegmentLayer = null;
            }
            if (clickMarker) {
                map.removeLayer(clickMarker);
                clickMarker = null;
            }
            localStorage.clear();
            currentSegmentNodes = [];
            document.getElementById('coordenadas').value = '';
            
            // Atualiza o display da rua ap√≥s cancelamento
            const ruaSelect = document.getElementById('ruaSelect');
            if (ruaSelect) {
                 ruaSelect.innerHTML = '<option value="">Selecione uma rua</option>';
            }

            document.getElementById('finalPolylineInput').value = '';
            document.getElementById('finalStreetNameInput').value = '';
            container.style.display = 'none';
showAlert('Sele√ß√£o de segmento cancelada. Clique no mapa para recome√ßar.', 'info');
            esconderBotaoReverso();
        };
    }


    // ===== Inicializa√ß√£o dos Event Listeners (Gatilho inicial) =====
    document.addEventListener('DOMContentLoaded', () => {
        const myMap = initializeMap();
        locateUser(myMap);
        
        myMap.on('click', handleMapClick);

        // Inicializa o select de dire√ß√£o
        atualizarDirecoes(document.getElementById('directionSelect'));
        
        // Listener para mudan√ßa de dire√ß√£o
   
         document.getElementById('directionSelect').addEventListener('change', (e) => {
            const newDirection = e.target.value;
            const savedSegment = localStorage.getItem(MAP_CONFIG.LOCAL_STORAGE_KEYS.SEGMENT);
            
            if (savedSegment) {
                const segmentNodes = JSON.parse(savedSegment);
             
                drawSegment(segmentNodes, 
newDirection);
                saveSegmentState(segmentNodes, newDirection);
                
                const container = document.getElementById('segmentSelectionContainer');
                container.dataset.tempSegmentDirection = newDirection;
            }
        });
        document.getElementById('starttime').addEventListener('change', calcularDiasSemana);
        document.getElementById('endtime').addEventListener('change', calcularDiasSemana);
// Listener para carregar subtipos
        document.getElementById('tipo').addEventListener('change', (e) => {
            const tipoId = e.target.value;
            loadSubtypes(tipoId);
        });
// Cria e adiciona o bot√£o de inverter para que ele possa ser manipulado
        mostrarBotaoReverso(null, map);
        esconderBotaoReverso(); // Esconde ele no in√≠cio
    });
</script>

<style>
    /* Estilos Aprimorados */
    #map {
        border-radius: 8px;
        transition: box-shadow 0.3s ease;
        height: 500px; /* Altura padr√£o para o desktop */
    }

    /* Em dispositivos m√≥veis, reduzir a altura do mapa */
    @media (max-width: 768px) {
        #map {
            height: 300px;
        }
    }

    #map:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .leaflet-popup-content {
        font-size: 14px;
        padding: 8px;
    }

    .btn-warning {
        background-color: #ffc107;
        border-color: #ffc107;
        transition: all 0.3s ease;
    }

    .btn-warning:hover {
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3);
    }

    /* Estilo para o novo painel de sele√ß√£o */
    #segmentSelectionContainer {
        border-left: 5px solid #ffc107 !important;
    }

    /* Ajustes de responsividade para os cards de hor√°rios */
    @media (max-width: 576px) {
        .card .row .col-md-4 {
            flex: 0 0 100%;
            max-width: 100%;
        }
    }
</style>
<script>
//FUNCIONANDO PERFEITAMENTE! GRA√áAS A DEUS!
// Fun√ß√£o para carregar subtipos usando a vari√°vel injetada pelo Twig (SEM AJAX)
function loadSubtypes(tipoId) {
    const subtipoSelect = document.getElementById('subtipo');
// Reseta o estado do campo
    subtipoSelect.innerHTML = '<option value="">Selecione um Subtipo</option>';
    subtipoSelect.disabled = true;
if (!tipoId) {
        return;
}
    
    // Obt√©m os subtipos do objeto global
    const subtypes = SUBTIPOS_POR_TIPO[tipoId] ||
[]; 

    if (subtypes.length > 0) {
        subtypes.forEach(subtipo => {
            const option = document.createElement('option');
            // Usamos o 'id' como o valor da op√ß√£o
            option.value = subtipo.id; 
            option.textContent = subtipo.name;
            subtipoSelect.appendChild(option);
        });
        subtipoSelect.disabled = false; // Habilita o campo ap√≥s o carregamento
    } else {
        subtipoSelect.innerHTML = '<option value="">Nenhum Subtipo Encontrado</option>';
    }
}

// O listener deve estar dentro do bloco DOMContentLoaded (como nos scripts anteriores)

// ... Dentro do seu document.addEventListener('DOMContentLoaded', () => { ...
document.getElementById('tipo').addEventListener('change', (e) => {
    const tipoId = e.target.value;
    loadSubtypes(tipoId);
});

</script>